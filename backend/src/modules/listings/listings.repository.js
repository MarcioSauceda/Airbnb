// backend/src/modules/listings/listings.repository.js
import oracledb from "oracledb";
import { withConn } from "../../config/oracle.js";
import {
  LISTINGS_LIST,
  LISTING_DETAIL,
  LISTING_IMAGES,
  LISTING_ADD_AMENITIES,
  LISTING_ADD_SERVICES,
} from "./listings.sql.js";

/* =========================================================
   META de esquema de TBL_ALOJAMIENTO (cacheada)
   ========================================================= */
let META = null;
async function ensureMeta() {
  if (META) return META;
  return withConn(async (c) => {
    const colsRes = await c.execute(
      `SELECT UPPER(column_name) AS COL
         FROM user_tab_columns
        WHERE table_name = 'TBL_ALOJAMIENTO'`,
      [],
      { outFormat: oracledb.OBJECT }
    );
    const cols = new Set(colsRes.rows.map((r) => r.COL));

    const hasPrecioFijo = cols.has("PRECIO_FIJO");
    const hasIdPrecio   = cols.has("ID_PRECIO");
    const hostCol = cols.has("ID_USUARIO_ANFITRION")
      ? "ID_USUARIO_ANFITRION"
      : (cols.has("ID_HUESPED") ? "ID_HUESPED" : null);

    if (!hostCol) {
      throw new Error("No se encontró columna de anfitrión (ID_USUARIO_ANFITRION o ID_HUESPED) en TBL_ALOJAMIENTO");
    }

    const tPrecios = await c.execute(
      `SELECT COUNT(*) AS N FROM user_tables WHERE table_name = 'TBL_PRECIOS'`,
      [],
      { outFormat: oracledb.OBJECT }
    );
    const hasTablaPrecios = (tPrecios.rows?.[0]?.N ?? 0) > 0;

    META = { hasPrecioFijo, hasIdPrecio, hasTablaPrecios, hostCol };
    return META;
  });
}

/* =========================================================
   Listado y detalle (como los tenías)
   ========================================================= */
export const listAll = () =>
  withConn(async (c) => {
    const r = await c.execute(LISTINGS_LIST, [], { outFormat: oracledb.OBJECT });
    return r.rows;
  });

export const detailById = (id) =>
  withConn(async (c) => {
    const base = await c.execute(LISTING_DETAIL, { id }, { outFormat: oracledb.OBJECT });
    const imgs = await c.execute(LISTING_IMAGES, { id }, { outFormat: oracledb.OBJECT })
      .catch(() => ({ rows: [] }));
    return { ...base.rows[0], images: imgs.rows };
  });

/* =========================================================
   Helper robusto: insertar precio y devolver ID_PRECIO
   - Intenta insert simple (funciona si hay IDENTITY/trigger)
   - Si ORA-01400, detecta secuencia y reintenta
   - Si no hay secuencia, lanza hint con DDL sugerido
   ========================================================= */
async function insertPrecio(c, precio_fijo) {
  // Intento 1: IDENTITY/trigger
  try {
    const r = await c.execute(
      `INSERT INTO TBL_PRECIOS (PRECIO_FIJO)
       VALUES (:precio_fijo)
       RETURNING ID_PRECIO INTO :out_id`,
      { precio_fijo, out_id: { dir: oracledb.BIND_OUT, type: oracledb.NUMBER } }
    );
    return r.outBinds.out_id[0];
  } catch (e) {
    const msg = String(e.message || "");
    // Si no es ORA-01400, relanzamos
    if (!msg.includes("ORA-01400") && e.errorNum !== 1400) throw e;
  }

  // Intento 2: buscar secuencia candidata
  const seqRes = await c.execute(
    `SELECT sequence_name
       FROM user_sequences
      WHERE sequence_name IN ('SEQ_TBL_PRECIOS','TBL_PRECIOS_SEQ','PRECIOS_SEQ')
         OR sequence_name LIKE '%PRECI%'
      ORDER BY CASE
                 WHEN sequence_name='SEQ_TBL_PRECIOS' THEN 0
                 WHEN sequence_name='TBL_PRECIOS_SEQ'  THEN 1
                 WHEN sequence_name='PRECIOS_SEQ'      THEN 2
                 ELSE 3
               END`,
    [],
    { outFormat: oracledb.OBJECT }
  );
  const seqName = seqRes.rows?.[0]?.SEQUENCE_NAME;

  if (!seqName) {
    const hint = [
      "-- Opción A: convertir a identity",
      "ALTER TABLE TBL_PRECIOS MODIFY (ID_PRECIO GENERATED BY DEFAULT ON NULL AS IDENTITY);",
      "",
      "-- Opción B: crear secuencia y usarla",
      "CREATE SEQUENCE SEQ_TBL_PRECIOS START WITH 1 INCREMENT BY 1 NOCACHE;",
    ].join("\n");
    const err = new Error("TBL_PRECIOS.ID_PRECIO no es identity y no se encontró secuencia para auto-incrementar.");
    err.hint = hint;
    throw err;
  }

  // Intento 3: insertar usando la secuencia detectada
  const r2 = await c.execute(
    `INSERT INTO TBL_PRECIOS (ID_PRECIO, PRECIO_FIJO)
     VALUES (${seqName}.NEXTVAL, :precio_fijo)
     RETURNING ID_PRECIO INTO :out_id`,
    { precio_fijo, out_id: { dir: oracledb.BIND_OUT, type: oracledb.NUMBER } }
  );
  return r2.outBinds.out_id[0];
}

/* =========================================================
   Crear anuncio (dinámico según tu esquema)
   ========================================================= */
export async function createListing(user, payload) {
  return withConn(async (c) => {
    const m = await ensureMeta();

    // 1) TBL_PRECIOS + ID_PRECIO (identity/trigger o secuencia)
    let id_precio = null;
    if (m.hasIdPrecio && m.hasTablaPrecios) {
      id_precio = await insertPrecio(c, payload.precio_fijo);
    }

    // 2) Armamos columnas/binds para TBL_ALOJAMIENTO
    const cols = [
      "ID_TIPO_ALOJAMIENTO",
      "TITULO",
      "DESCRIPCION",
      "NUM_HABITACIONES",
      "NUM_CAMAS",
      "NUM_BANOS",
      m.hostCol,
    ];
    const binds = {
      ID_TIPO_ALOJAMIENTO: payload.id_tipo_alojamiento,
      TITULO: payload.titulo,
      DESCRIPCION: payload.descripcion,
      NUM_HABITACIONES: payload.num_habitaciones,
      NUM_CAMAS: payload.num_camas,
      NUM_BANOS: payload.num_banos,
      [m.hostCol]: user.id_usuario, // del JWT
    };

    // 3) Guardar precio donde corresponda
    if (m.hasIdPrecio && id_precio !== null) {
      cols.push("ID_PRECIO");
      binds.ID_PRECIO = id_precio;
    } else if (m.hasPrecioFijo) {
      cols.push("PRECIO_FIJO");
      binds.PRECIO_FIJO = payload.precio_fijo;
    }

    // 4) INSERT y obtener ID
    const sql = `
      INSERT INTO TBL_ALOJAMIENTO (${cols.join(",")})
      VALUES (${cols.map((c) => ":" + c).join(",")})
      RETURNING ID_ALOJAMIENTO INTO :out_id
    `;
    const res = await c.execute(sql, {
      ...binds,
      out_id: { dir: oracledb.BIND_OUT, type: oracledb.NUMBER },
    });
    const id = res.outBinds.out_id[0];

    // 5) Relaciones amenidades/servicios (si vienen)
    if (payload.amenidades?.length) {
      await c.executeMany(
        LISTING_ADD_AMENITIES,
        payload.amenidades.map((aid) => ({
          id_alojamiento: id,
          id_amenidad: aid,
        }))
      );
    }
    if (payload.servicios?.length) {
      await c.executeMany(
        LISTING_ADD_SERVICES,
        payload.servicios.map((sid) => ({
          id_alojamiento: id,
          id_servicio: sid,
        }))
      );
    }

    return id;
  });
}

/* =========================================================
   IMÁGENES: insertar en IMAGEN_ALOJAMIENTO (tolerante a columnas)
   ========================================================= */
let META_IMG = null;
async function ensureMetaImages() {
  if (META_IMG) return META_IMG;
  return withConn(async (c) => {
    const colsRes = await c.execute(
      `SELECT UPPER(column_name) AS COL
         FROM user_tab_columns
        WHERE table_name = 'IMAGEN_ALOJAMIENTO'`,
      [],
      { outFormat: oracledb.OBJECT }
    );
    const cols = new Set(colsRes.rows.map((r) => r.COL));

    const pathCol = [
      "URL", "RUTA", "PATH", "URL_IMAGEN", "NOMBRE_ARCHIVO", "IMAGEN", "IMAGEN_URL"
    ].find((n) => cols.has(n));
    if (!pathCol) throw new Error("No se encontró columna de ruta/url en IMAGEN_ALOJAMIENTO");

    const hasId = cols.has("ID_IMAGEN");
    if (!cols.has("ID_ALOJAMIENTO")) {
      throw new Error("IMAGEN_ALOJAMIENTO no tiene columna ID_ALOJAMIENTO");
    }

    META_IMG = { pathCol, hasId };
    return META_IMG;
  });
}

export async function insertListingImages(listingId, files, publicBase = "/uploads") {
  return withConn(async (c) => {
    const meta = await ensureMetaImages();
    const images = [];

    for (const f of files) {
      const url = `${publicBase}/listings/${listingId}/${f.filename}`;
      const r = await c.execute(
        `INSERT INTO IMAGEN_ALOJAMIENTO (ID_ALOJAMIENTO, ${meta.pathCol})
         VALUES (:id, :url)
         ${meta.hasId ? "RETURNING ID_IMAGEN INTO :out_id" : ""}`,
        meta.hasId
          ? { id: listingId, url, out_id: { dir: oracledb.BIND_OUT, type: oracledb.NUMBER } }
          : { id: listingId, url }
      );

      images.push({
        id: meta.hasId ? r.outBinds.out_id[0] : null,
        url,
      });
    }

    return { ok: true, inserted: images.length, images };
  });
}

/* Compat: si en el service llaman insertListing, apunta a createListing */
export const insertListing = createListing;
